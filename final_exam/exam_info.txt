기말고사 총 25문제 / 객관식 only

--------------------------------------------------------------------

다음 8가지 기본형 중 정수형 타입이 아닌 것은?
1. byte
2. int
3. double
4. long

답: 3번 

논리형 : boolean
문자형 : char
정수형 : byte, short, int, long
실수형 : float, double 

------------------------------------------------------------

자바의 변수이름 규칙에 어긋나는 것은?
1. 대소문자가 구분되며 길이에 제한이 없다.
2. 특수문자는 '_' 와 '$' 만이 허용된다.
3. 예약어를 사용해서는 안 된다.
4. 숫자로 시작해도 된다.

답: 4번 

변수이름은 맨 앞에 숫자가 나오면 안된다.
숫자가 중간이나 뒤에 나오는 것은 괜찮다.
7max (x)
top10 (o)

------------------------------------------------------------------

다음 중 조건문에 대한 설명으로 틀린 것은?
1. if 문을 사용할 때 else if 문은 여러 개를 사용해도 된다.
2. if 없이 else if 와 else 만을 사용할 수 있다.
3. if 문 안에 if 문을 중첩해서 사용할 수 있다.
4. else if 없이 if 와 else 만을 사용할 수 있다. 

답: 2번 

if 문은 if 가 맨 위에 꼭 있어야 한다. 

------------------------------------------------------------------------

조건문에 대한 설명으로 틀린 것은?

1. switch 문보다는 if 문을 더 많이 사용한다.
2. 모든 switch 문은 if 문으로 변경가능하다.
3. switch 문에서 case 에 대항하는 것들이 없으면, else 를 실행한다. 
4. if 문은 switch 문으로 변경할 수 없는 경우가 많다.

답: 3번 

switch문에서 case 에 해당하는 것이 없으면 default 를 실행한다. 

--------------------------------------------------------------------------------

반복문에 대한 설명으로 틀린 것은?

1. 반복횟수가 중요한 경우에는 for 문을 그 외에는 while 문을 사용한다.
2. for 문과 while 문은 서로 변경가능하다.
3. 블록 { } 이 최소한 한 번은 수행될 것을 보장하기 위해서는 while 문을 사용한다.
4. for 문의  ()안에 비교 부분을 생략해도 된다.
   for (int i = 0;     ;  i++)

답: 3번 

블록이 { } 이 최소한 한 번은 수행될 것을 보장하기 위해서는 do while 문을 사용해야 한다.
do while 문은 일단 실행을 하고 끝에 있는 조건식을 따라 실행한다.

--------------------------------------------------------------------------------------

for 문이 수행되는 순서가 맞는 것은?

1. 초기화 -> 수행될 문장 -> 증감식 -> 조건식 
2. 초기화 -> 조건식 -> 수행될 문장 -> 증감식 
3. 초기화 -> 조건식 -> 증감식 -> 수행될 문장 
4. 초기화 -> 증감식 -> 조건식 -> 수행될 문장 

답: 2번 

초기화 -> 조건식 -> 수행될 문장 -> 증감식을 수행하고 초기화는 한 번만 수행하며 그 다음부터는 
조건식 -> 수행될 -> 증감식을 실행하며 조건에 맞을 때까지 실행한다.

---------------------------------------------------------------------------------------------

배열에 대한 설명으로 틀린 것은?
1. 같은 타입의 여러 변수들을 하나의 묶음으로 다루는 것이다.
2. 많은 양의 데이터를 다룰 때 유용하다.
3. 배열을 선언하면 값을 저장할 공간이 생긴다.
4. 배열의 각 요소는 서로 연속적이다.

답: 3번

배열을 선언하면 값을 저장할 공간이 생기는 것이 아니라, 
저장할 공간의 주소를 담는 공간이 생기는 것이다. 

int[] abc; // 선언만 하면 주소만 생긴다.
int[] abc = new int[3]; // 선언 후 인스턴스화를 통해 값을 저장할 공간이 생긴다.

----------------------------------------------------------------------------------------------------

다음 중 배열의 초기화로 틀린 것은?

1. int[] score = {10,30,40,60};
2. int[] score = new int] {10, 30, 40, 60};
3. int[] score; score = {10, 30, 40, 60};
4. int[] score; score = new int[] [10, 30, 40, 60];

답: 3번 

배열은 선언만 된 상태에서 참조변수에 배열 값을 저장할 수 없다. 
배열 값을 생성한 후에야 배열 값을 저장할 수 있다.

-----------------------------------------------------------------------------------

다음은 배열을 선언하거나 초기화한 것이다.
잘못된 것을 고르시오.

1. int[] arr[];
2. int[] arr = {1,2,3};
3. int arr[5];
4. int[] arr = new int[5];

답: 3번 

배열은 선언만 한 상태에서는 값을 저장할 공간이 할당되지 않기 때문에
선언하면서 방의 수를 정할 수 없다.

-----------------------------------------------------------------------------------

변수가 선언된 위치에 따라 변수의 종류를 알 수 있다.
다음 중 변수의 위치에 따른 변수의 종류가 아닌 것은?

1. 클래스 변수 
2. 인스턴스 변수 
3. 배열 변수 
4. 지역 변수 

답: 3번 

------------------------------------------------------------------------------------------

다음 중 생성자에 대한 설명으로 틀린 것은?

1. 모든 생성자의 이름은 클래스의 이름과 동일해야 한다.
2. 생성자는 객체를 생성하기 위한 것이다.
3. 클래스에서는 생성자가 하나 이상 있어야 한다.
4. 생성자가 없는 클래스는 컴파일러가 기본 생성자를 추가한다.

답: 2번 

생성자는 객체를 초기화할 목적으로 사용되는 것이다.
객체를 생성하는 것은 new 연산자이다.

-------------------------------------------------------------------------------

다음 중 this 에 대한 설명으로 맞지 않는 것은?
1. 객체 자신을 가리키는 참조변수이다.
2. 클래스 내에서라면 어디서든 사용할 수 있다.
3. 지역변수와 인스턴스변수를 구분할 때 사용된다.
4. 클래스 메소드 내에서는 사용할 수 없다.

답: 2번 

-----------------------------------------------------------------------------

다음 중 오버로딩이 성립하기 위한 조건이 아닌 것은?
1. 메소드의 이름이 같아야 한다.
2. 매개변수의 개수가 달라야 한다.
3. 리턴타입이 달라야 한다.
4. 매개변수의 타입이 달라야 한다. 

답: 3번 

--------------------------------------------------------------------

다음 중 아래의 add 메소드를 오버로딩한 것이 아닌 것은?

long add(int a, int b) {
	return a + b;
}

1. long add(int x, int y) { return x + y; }
2. long add(long a, long b) { return a + b; }
3. int add(byte a, byte b) { return a + b; }
4. int add(long a, long b) { return (int)(a + b); }

답: 1번 

[오버로딩의 조건]
1. 매소드의 이름이 같아야 한다.
2. 매개변수의 개수 또는 타입이 달라야 한다.

--------------------------------------------------------------------

다음 중 초기화에 대한 설명으로 옳지 않은 것은? 3
1. 멤버변수는 자동 초기화되므로 초기화 하지 않고도
   값을 참조할 수 있다.
2. 지역변수는 반드시 초기화해야 한다.
3. 초기화 블럭보다 생성자가 먼저 수행된다.
4. 명시적 초기화를 제일 우선적으로 고려해야 한다.

답: 3번

클래스변수는 클래스가 처음 메모리에 로딩될 때 
  자동초기화되므로 인스턴스 변수보다 먼저 초기화된다
그리고 생성자는 초기화블럭이 수행된 다음에 수행된다.

-----------------------------------------------------------------------------

다음 중 인스턴스변수의 초기화 순서가 올바른 것은? 1
1. 기본값 - 명시적 초기화 - 초기화블럭 - 생성자
2. 기본값 - 명시적 초기화 - 생성자 - 생성자블럭
3. 기본값 - 초기화블럭 - 명시적초기화 - 생성자
4. 기본값 - 초기화블럭 - 생성자 - 명시적초기화

답: 1번 

----------------------------------------------------------------------------------

다음 중 지역변수에 대한 설명으로 옳지 않는 것은? 1
1. 자동 초기화되므로 별도의 초기화가 필요없다.
2. 지역변수가 선언된 메소드가 종료되면,
   지역변수도 함께 소멸된다.
3. 메소드의 매개변수로 선언된 변수도 지역변수이다.
4. 클래스변수나 인스턴스변수보다 메모리의 부담이 적다.

답: 1번 

------------------------------------------------------------------------------
 
다음 중 오버라이딩의 조건으로 옳지 않은 것은?

1. 조상의 메소드와 이름이 같아야 한다.
2. 매개변수의 수와 타입이 모두 같아야 한다.
3. 리턴타입이 같아야 한다.
4. 조상의 메소드보다 더 많은 수의 예외를 선언할 수 있다.

답: 4번

-------------------------------------------------------------------------------

다음 중 접근제어자의 대한 설명으로 옳지 않은 것은?

1. public - 같은 클래스와 같은 패키지 내에서만 접근이 가능하다.
2. private - 같은 클래스 내에서만 접근이 가능하다.
3. protected - 같은 패키지 내에서, 그리고 다른 패키지의 클래스에서 접근이 가능하다.
4. default - 같은 패키지 내에서만 접근이 가능하다. 

답: 1번 

-----------------------------------------------------------------------------------------

데이터를 select할 때 중복되는 행을 제거하기 위해 사용하는 것은?

1. sum
2. avg
3. distinct
4. alias 

답: 3번 

-------------------------------------------------------------------------

NULL 값을 말하는 것 중 틀린 것은?

1. NULL은 0이나 공백(space)와 다르다.
2. NULL값을 포함한 산술 표현식의 결과는 NULL이다.
3. NULL은 0대신 사용하기 위한 것이다.
4. 컬럼에 데이터 값이 없으면, 그 값 자체가 NULL 또는 NULL 값을 포함하고 있는 것이다.

답: 3번 

[NULL값의 정의]
NULL은 이용할 수 없고 할당되지 않고 
알려져 있지도 않으며 적용 불가한 값을 말한다.
NULL이란 0이나 공백(Space)과는 다르다.
NULL값을 포함한 산술 표현식의 결과는 NULL이다.
Column에 데이터 값이 없으면,
  그 값 자체가 NULL 또는 NULL값을 포함하고 있는 것이다.
NULL값은 1바이트의 내부 저장 장치를 
  오버헤드로 사용하고 있으며, 
  어떠한 datatype column이라도 NULL값을 포함할 수 있다.

----------------------------------------------------------------------------------

LIKE 연산자를 나타내는 말 중 틀린 것은? 4
1. 와일드 카드 검색을 위해서 사용한다.
2. 검색 조건은 문자나 숫자 포함 가능하다.
3. '%'는 없거나 하나 이상의 문자와 대치한다.
4. '$'는 하나의 문자와 대치된다.

하나의 문자를 대치하는 것은 '_'이다.

--------------------------------------------------------------
  
우선 순위 규칙 순서에 어긋나는 것은? 3
1. 괄호 > NOT > AND
2. 비교연산자 > NOT > OR
3. 괄호 > AND > 비교연산자
4. NOT > AND > OR

[우선 순위 규칙]
1. 괄호
2. 비교연산자
3. NOT
4. AND
5. OR

----------------------------------------------------------

다음 중 그룹 함수가 아닌 것은? 4 (데이터베이스)
1. COUNT
2. MAX
3. SUM
4. TOTAL

[그룹함수]
COUNT, MAX, MIN, SUM, AVG

-------------------------------------------------------------------

다음 중 잘못 설명된 것은? 2 (데이터베이스)
1. GROUP BY절을 사용하여 테이블 내에서
   보다 작은 그룹으로 나눌 수 있다.
2. 그룹 함수에 포함되지 않은, SELECT절의 모든 COLUMN은
   반드시 GROUP BY절에 명시되지 않아도 된다.
3. ORDER BY절을 사용할 때 기본은 ASC이다.
4. GROUP BY절에 쓰인 COLUMN이
   반드시 SELECT절에 포함될 필요는 없다.
   
그룹 함수에 포함되지 않은 SELECT절의 모든 COLUMNE은
반드시 GROUP BY절에 명시되어야 한다.

-----------------------------------------------------------------------------

서브쿼리 사용시 틀린 것은? 1 (데이터베이스)
1. 서브쿼리는 반드시 {}로 묶어서 사용해야 한다.
2. 서브쿼리는 비교 연산자의 오른쪽에 기술해야 한다.
3. 서브쿼리안에는 ORDER BY절을 쓸 수 없다.
4. 다중행 SUBQUERY는 다중행 연산자(IN, ANY, ALL)와
   함께 사용해야 한다.
   
[SUBQUERY 사용시 주의 사항]
SUBQUERY는 반드시 괄호()로 묶어야 한다.
SUBQUERY는 비교 연산자의 오른쪽에 기술해야 한다.
단일행 SUBQUERY는 단일행 연산자( >, =, >=, <, <=, <>)와
  함께 사용해야 한다.
다중행 SUBQUERY는 다중행 연산자(IN, ANY, ALL)와 함께
사용해야 한다.

----------------------------------------------------------------------------------

다음 중 설명이 잘못된 것은? 4 (안드로이드)
1. activity_main.xml	- 기본 액티비티(메인)
2. MainActivity.java	- 메인 자바 코드
3. drawable 폴더		- 앱에서 사용할 이미지 파일을
                          저장하는 폴더
4. AndroidManifest.xml	- 앱의 기본 레이아웃과 관련된
						  파일

----------------------------------------------------------------------------------   
   
다음 중 레이아웃이 아닌 것은? 3 (안드로이드)
1. LinearLayout
2. RelativeLayout
3. ArrayLayout
4. GridLayout
  
----------------------------------------------------------------------------------------
   
다음 중 설명이 잘못된 것은? 1 (안드로이드)
1. 레이아웃안에 레이아웃을 작성할 수 없다.
2. padding속성을 사용하여 위젯의 경계선으로 부터
   위젯 안의 요소가 떨어지도록 설정할 수 있다.
3. visibility속성을 사용하여 위젯을 보일 것인지 여부를
   결정할 수 있다.
4. Button위젯에서 clickable속성으로 클릭이나 터치를
   못하게 할 수 있다.

----------------------------------------------------------------------------------------------

다음 중 레이아웃에 대한 설명 중 잘못된 것은? 1 (안드로이드)
1. RelativeLayout은 orientation을 기본구성으로 한다.
2. TableLayout은 표 형태로 배치할 때 사용한다.
3. GridLayout은 TableLayout보다 좀 더 직관적으로 구성
   할 수 있으며, 행 단위의 확장도 가능하다.
4. FrameLayout은 레이아웃 안의 위젯들을
   좌측 상단에 겹쳐서 출력한다.

----------------------------------------------------------------------------------------

다음 중 설명이 잘못된 것은? (아두이노)

1. void setup() {} 은 초기변수, 핀 상태, 사용 라이브러리 시작 등에 사용된다.
2. void setup() {} 은 보드에서 전원 공급시 한 번에 한해서 실행할 내용을 작성한다.
3. void loop() {} 는 한 번만 실행되기 때문에 반복해서 실행할 내용은 반복문을 작성해서 해결해야 한다.
4. void loop() {} 는 반복해서 실행할 내용을 작성한다.

답: 3번 

-------------------------------------------------------------------------------------------

다음 중 설명이 잘못된 것은? (아두이노)

1. pinMode(11, OUTPUT) - 11핀을 출력모드로 설정한다.
2. pinMode(OUTPUT, 13) - 13핀을 출력모드로 설정한다.
3. pinMode(12, OUTPUT) - 12핀을 입력모드로 설정한다.
4. Serial.begin(9600)       - 시리얼 Baurate 를 9600 으로 설정 

답: 2번 

-------------------------------------------------------------------------------

다음 중 설명이 잘못된 것은? (아두이노)

1. Serial.print(". . .") - 시리얼모니터에 따옴표 내의 내용을 출력한다.
2. Serial.available() - 시리얼포트의 버퍼에 저장된 자료를 체크하는 함수이다.
3. Serial.read() - 시리얼모니터에서 입력한 값을 읽어오는 함수이다.
4. Serial.parseInt() - 버퍼에 저장된 내용 중 정수와 실수를 읽어오는 함수이다. 

답: 4번 

--------------------------------------------------------------------------------------

다음 중 설명이 잘못된 것은? (아두이노)

1. 가변 저항의 값은 오직 0과 1로 고정하게 된다.
2. 조도센서는 빛의 밝기를 측정하는 아날로그센서이다.
3. 초음파센서를 이용하면 거리를 측정할 수 있다.
4. 초음파센서는 Trig과 Echo를 통해 거리를 측정한다.

답: 1번 





















