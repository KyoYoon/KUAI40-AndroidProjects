기말고사 총 25문제 / 객관식 only

--------------------------------------------------------------------

다음 8가지 기본형 중 정수형 타입이 아닌 것은?
1. byte
2. int
3. double
4. long

답: 3번 

논리형 : boolean
문자형 : char
정수형 : byte, short, int, long
실수형 : float, double 

------------------------------------------------------------

자바의 변수이름 규칙에 어긋나는 것은?
1. 대소문자가 구분되며 길이에 제한이 없다.
2. 특수문자는 '_' 와 '$' 만이 허용된다.
3. 예약어를 사용해서는 안 된다.
4. 숫자로 시작해도 된다.

답: 4번 

변수이름은 맨 앞에 숫자가 나오면 안된다.
숫자가 중간이나 뒤에 나오는 것은 괜찮다.
7max (x)
top10 (o)

------------------------------------------------------------------

다음 중 조건문에 대한 설명으로 틀린 것은?
1. if 문을 사용할 때 else if 문은 여러 개를 사용해도 된다.
2. if 없이 else if 와 else 만을 사용할 수 있다.
3. if 문 안에 if 문을 중첩해서 사용할 수 있다.
4. else if 없이 if 와 else 만을 사용할 수 있다. 

답: 2번 

if 문은 if 가 맨 위에 꼭 있어야 한다. 

------------------------------------------------------------------------

조건문에 대한 설명으로 틀린 것은?

1. switch 문보다는 if 문을 더 많이 사용한다.
2. 모든 switch 문은 if 문으로 변경가능하다.
3. switch 문에서 case 에 대항하는 것들이 없으면, else 를 실행한다. 
4. if 문은 switch 문으로 변경할 수 없는 경우가 많다.

답: 3번 

switch문에서 case 에 해당하는 것이 없으면 default 를 실행한다. 

--------------------------------------------------------------------------------

반복문에 대한 설명으로 틀린 것은?

1. 반복횟수가 중요한 경우에는 for 문을 그 외에는 while 문을 사용한다.
2. for 문과 while 문은 서로 변경가능하다.
3. 블록 { } 이 최소한 한 번은 수행될 것을 보장하기 위해서는 while 문을 사용한다.
4. for 문의  ()안에 비교 부분을 생략해도 된다.
   for (int i = 0;     ;  i++)

답: 3번 

블록이 { } 이 최소한 한 번은 수행될 것을 보장하기 위해서는 do while 문을 사용해야 한다.
do while 문은 일단 실행을 하고 끝에 있는 조건식을 따라 실행한다.

--------------------------------------------------------------------------------------

for 문이 수행되는 순서가 맞는 것은?

1. 초기화 -> 수행될 문장 -> 증감식 -> 조건식 
2. 초기화 -> 조건식 -> 수행될 문장 -> 증감식 
3. 초기화 -> 조건식 -> 증감식 -> 수행될 문장 
4. 초기화 -> 증감식 -> 조건식 -> 수행될 문장 

답: 2번 

초기화 -> 조건식 -> 수행될 문장 -> 증감식을 수행하고 초기화는 한 번만 수행하며 그 다음부터는 
조건식 -> 수행될 -> 증감식을 실행하며 조건에 맞을 때까지 실행한다.

---------------------------------------------------------------------------------------------

배열에 대한 설명으로 틀린 것은?
1. 같은 타입의 여러 변수들을 하나의 묶음으로 다루는 것이다.
2. 많은 양의 데이터를 다룰 때 유용하다.
3. 배열을 선언하면 값을 저장할 공간이 생긴다.
4. 배열의 각 요소는 서로 연속적이다.

답: 3번

배열을 선언하면 값을 저장할 공간이 생기는 것이 아니라, 
저장할 공간의 주소를 담는 공간이 생기는 것이다. 

int[] abc; // 선언만 하면 주소만 생긴다.
int[] abc = new int[3]; // 선언 후 인스턴스화를 통해 값을 저장할 공간이 생긴다.

----------------------------------------------------------------------------------------------------

다음 중 배열의 초기화로 틀린 것은?

1. int[] score = {10,30,40,60};
2. int[] score = new int] {10, 30, 40, 60};
3. int[] score; score = {10, 30, 40, 60};
4. int[] score; score = new int[] [10, 30, 40, 60];

답: 3번 

배열은 선언만 된 상태에서 참조변수에 배열 값을 저장할 수 없다. 
배열 값을 생성한 후에야 배열 값을 저장할 수 있다.

-----------------------------------------------------------------------------------

다음은 배열을 선언하거나 초기화한 것이다.
잘못된 것을 고르시오.

1. int[] arr[];
2. int[] arr = {1,2,3};
3. int arr[5];
4. int[] arr = new int[5];

답: 3번 

배열은 선언만 한 상태에서는 값을 저장할 공간이 할당되지 않기 때문에
선언하면서 방의 수를 정할 수 없다.

-----------------------------------------------------------------------------------

변수가 선언된 위치에 따라 변수의 종류를 알 수 있다.
다음 중 변수의 위치에 따른 변수의 종류가 아닌 것은?

1. 클래스 변수 
2. 인스턴스 변수 
3. 배열 변수 
4. 지역 변수 

답: 3번 

------------------------------------------------------------------------------------------

다음 중 생성자에 대한 설명으로 틀린 것은?

1. 모든 생성자의 이름은 클래스의 이름과 동일해야 한다.
2. 생성자는 객체를 생성하기 위한 것이다.
3. 클래스에서는 생성자가 하나 이상 있어야 한다.
4. 생성자가 없는 클래스는 컴파일러가 기본 생성자를 추가한다.

답: 2번 

생성자는 객체를 초기화할 목적으로 사용되는 것이다.
객체를 생성하는 것은 new 연산자이다.

-------------------------------------------------------------------------------

다음 중 this 에 대한 설명으로 맞지 않는 것은?
1. 객체 자신을 가리키는 참조변수이다.
2. 클래스 내에서라면 어디서든 사용할 수 있다.
3. 지역변수와 인스턴스변수를 구분할 때 사용된다.
4. 클래스 메소드 내에서는 사용할 수 없다.

답: 2번 

-----------------------------------------------------------------------------

다음 중 오버로딩이 성립하기 위한 조건이 아닌 것은?
1. 메소드의 이름이 같아야 한다.
2. 매개변수의 개수가 달라야 한다.
3. 리턴타입이 달라야 한다.
4. 매개변수의 타입이 달라야 한다. 

답: 3번 

--------------------------------------------------------------------

다음 중 아래의 add 메소드를 오버로딩한 것이 아닌 것은?

long add(int a, int b) {
	return a + b;
}

1. long add(int x, int y) { return x + y; }
2. long add(long a, long b) { return a + b; }
3. int add(byte a, byte b) { return a + b; }
4. int add(long a, long b) { return (int)(a + b); }

답: 1번 

[오버로딩의 조건]
1. 매소드의 이름이 같아야 한다.
2. 매개변수의 개수 또는 타입이 달라야 한다.

--------------------------------------------------------------------

다음 중 초기화에 대한 설명으로 옳지 않은 것은? 3
1. 멤버변수는 자동 초기화되므로 초기화 하지 않고도
   값을 참조할 수 있다.
2. 지역변수는 반드시 초기화해야 한다.
3. 초기화 블럭보다 생성자가 먼저 수행된다.
4. 명시적 초기화를 제일 우선적으로 고려해야 한다.

답: 3번

클래스변수는 클래스가 처음 메모리에 로딩될 때 
  자동초기화되므로 인스턴스 변수보다 먼저 초기화된다
그리고 생성자는 초기화블럭이 수행된 다음에 수행된다.

-----------------------------------------------------------------------------

다음 중 인스턴스변수의 초기화 순서가 올바른 것은? 1
1. 기본값 - 명시적 초기화 - 초기화블럭 - 생성자
2. 기본값 - 명시적 초기화 - 생성자 - 생성자블럭
3. 기본값 - 초기화블럭 - 명시적초기화 - 생성자
4. 기본값 - 초기화블럭 - 생성자 - 명시적초기화

답: 1번 

------------------------------------------------------------------------------
 














